import { Animated, Dimensions, Platform, TouchableOpacity } from 'react-native';
import { ButtonText, SnackbarWrapper } from '../Styled/StyledComponents';
import React, { useCallback, useEffect, useImperativeHandle, useState, } from 'react';
import styled from '@emotion/native';
import { useTheme } from '@dooboo-ui/theme';
export var SnackbarTimer;
(function (SnackbarTimer) {
    SnackbarTimer[SnackbarTimer["SHORT"] = 1500] = "SHORT";
    SnackbarTimer[SnackbarTimer["LONG"] = 3000] = "LONG";
})(SnackbarTimer || (SnackbarTimer = {}));
const TextAction = styled.Text `
  color: ${({ theme, type }) => type === 'danger' ? theme.text.contrast : theme.text.basic};
`;
const Divider = styled.View `
  width: 1px;
  height: 100%;
  margin: 0 16px;
  opacity: 0.4;

  background-color: ${({ theme, type }) => type === 'danger' ? theme.text.contrast : theme.text.basic};
`;
const SnackbarContainer = (props, ref) => {
    const { testID } = props;
    const [showingState, setShowingState] = useState({
        isVisible: false,
        isShowing: false,
    });
    const [snackbar, setSnackbar] = useState({
        content: { text: '' },
        timer: SnackbarTimer.SHORT,
    });
    const { content, type = 'primary', actionText, onActionPress, styles, timer = SnackbarTimer.SHORT, } = snackbar;
    const { theme } = useTheme();
    const { isShowing, isVisible, timeout } = showingState;
    const [fadeAnim] = useState(new Animated.Value(0));
    const show = (c) => {
        setSnackbar(c);
        timeout && clearTimeout(timeout);
        setShowingState((prevState) => Object.assign(Object.assign({}, prevState), { isShowing: true }));
    };
    const hide = useCallback((duration = 200) => {
        Animated.timing(fadeAnim, {
            toValue: 0,
            duration,
            useNativeDriver: Platform.select({
                web: false,
                default: true,
            }),
        }).start(() => setShowingState((prevState) => Object.assign(Object.assign({}, prevState), { isVisible: false })));
    }, [fadeAnim]);
    useEffect(() => {
        if (isShowing) {
            if (isVisible) {
                hide(50);
            }
            else {
                const hideTimeout = setTimeout(() => {
                    hide();
                }, timer + 200);
                setShowingState({
                    isShowing: false,
                    isVisible: true,
                    timeout: hideTimeout,
                });
                Animated.timing(fadeAnim, {
                    toValue: 1,
                    duration: 200,
                    useNativeDriver: Platform.select({
                        web: false,
                        default: true,
                    }),
                }).start();
            }
        }
    }, [showingState, fadeAnim, hide, isShowing, isVisible, timer]);
    useImperativeHandle(ref, () => ({ show }));
    return (<>
      {showingState.isVisible && (<SnackbarWrapper testID={testID} type={type} style={[
                styles?.container,
                {
                    shadowColor: 'black',
                    shadowOffset: {
                        width: 0,
                        height: 4,
                    },
                    shadowOpacity: 0.15,
                    shadowRadius: 12,
                },
                { maxWidth: Dimensions.get('screen').width - 40 },
                { opacity: fadeAnim },
            ]}>
          {content.element ? (content.element) : (<ButtonText style={styles?.text} type={type}>
              {content.text}
            </ButtonText>)}
          {actionText && (<Divider theme={theme} type={type} style={{
                    height: Platform.select({ web: 24, default: 12 }),
                }}/>)}
          {actionText && (<TouchableOpacity onPress={onActionPress}>
              <TextAction theme={theme} type={type} style={styles?.text}>
                {actionText}
              </TextAction>
            </TouchableOpacity>)}
        </SnackbarWrapper>)}
    </>);
};
export const Snackbar = React.forwardRef(SnackbarContainer);
